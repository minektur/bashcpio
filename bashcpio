#!/bin/bash

#pointer to beginning of current file to be extracted
declare -i current_base=0
#some other (integer) globals 
declare -i filesize
declare -i namesize
declare -i fileperm
declare -i filetype
declare -i mtime
declare pkg

cmd_line () {
    pkg=$1
    if [ "$pkg" = "" -o ! -e "$pkg" ]; then
        echo "no package supplied" 1>&2
        exit 1
    fi
}


# get_chunk(skipbytes, chunklen, [savefile])
#    return value in get_chunk_return or saved into savefile
#    if savefile is specified
#    note the use of the global current_base - points to the current file record
#    so that this code can be used on any file in the archive
declare get_chunk_return=""
get_chunk () {
    local skp
    local siz
    local file
    declare -i skp=$1+$current_base
    siz=$2
    file=$3
    if [ "$3"x != 'x' ]; then
        file=" of=$3 "
    else
        file=""
    fi
    get_chunk_return=`dd if="$pkg" count=$siz skip=$skp $file iflag=count_bytes,skip_bytes 2>/dev/null`
}

# extract_file(namesize, fname, flength )
#     saves the current file, sets perms, owners?
extract_file () {
    local sb
    local dir
    local namesize
    local fname
    local flength
    local ds
    namesize=$1
    fname=$2
    flength=$3

    #sb bytes (skipped) will now get us to beginning of file contents
    # header size = 13*8  + 6  + filenamesize (including 1 null byte)
    #  + null padding to make the whole thing be a multiple of 4
    sb=$(( 110 + $namesize ))
    sb=$(( $sb + (( 4 - ( $sb % 4 )) % 4 ) ))


    # TODO replace dirname with something stupid and complicated later
    #   using only builtins... maybe
    dir=`dirname $fname`
    #TODO: umask on dir creation?
    mkdir -p $dir
    echo "x: $fname"
    #TODO: chroot here maybe, or some sanitization of path name 
    # remove leading slashes and dots until first non-slash/dot?
    get_chunk $sb $flength $fname
    #only works if running as root - silently ignore errors
    chown $uid:$gid $fname > /dev/null 2>&1
    chmod $fileperm $fname 
    
    ds=$( date -d @$mtime +%Y%m%d%H%M.%S )
    touch -c -m -t $ds $fname
}

extract_dir () {
    dirname=$1
    mkdir -p $dirname
    #only works if running as root - silently ignore errors
    chown $uid:$gid $dirname > /dev/null 2>&1
    chmod $fileperm $dirname
}

# read header of current record using fixed offsets
#   set a bunch of global variables
read_header () {
    # dont bother getting header fields we dont need
    get_chunk 0   6; magic=$get_chunk_return
    #get_chunk 6   8; ino=$get_chunk_return
    get_chunk 14  8; mode=$get_chunk_return
    get_chunk 22  8; uid=$get_chunk_return
    get_chunk 30  8; gid=$get_chunk_return
    #get_chunk 38  8; nlink=$get_chunk_return
    get_chunk 46  8; mtime=0x$get_chunk_return
    get_chunk 54  8; filesize=0x$get_chunk_return
    #get_chunk 62  8; devmajor=$get_chunk_return
    #get_chunk 70  8; devmajor=$get_chunk_return
    #get_chunk 78  8; rdevminor=$get_chunk_return
    #get_chunk 86  8; rdevminor=$get_chunk_return
    get_chunk 94  8;  namesize=0x$get_chunk_return
    #get_chunk 102 8; check=$get_chunk_return
    get_chunk 110 $namesize; fname=$get_chunk_return

    #mask and convert to octal
    fileperm=$(printf "%o" "0x${mode:5}")
    #extract filetype section
    filetype=0x${mode:0:5}
}

#verifies that we read a supported record type
check_magic () {
    if [ "$magic" != "070701" ] && [ "$magic" != "070702" ] ; then
        echo "Invalid header - not a cpio archive?"
        echo $magic
        exit 1
    fi
    return 0
}

# everything to extract a file out of a cpio archive
#  as pointed at by $current_base
get_one_file () {
    local sb

    read_header 
    check_magic

    # only handle files and directories leaving a bunch of types 
    # that are just begging for implementation.  Their cries have
    # fallen on deaf ears, devices... hm?  hardlinks?  symlinks?
    # is it linkcount or filesize that indicates hard links?  

    #TODO: check for last field and return 1

    if  [ $fname = 'TRAILER!!!' ]; then
        #end of archive
        return 1
    fi

    case $filetype in
       8)
            extract_file $namesize $fname $filesize ;;
       4)
            extract_dir $fname ;;
       *)
            echo "Unsupported filetype: $filetype   for $fname"
    esac
    
    #giant PITA getting this padding right.
    #header + name + padding AND math in bash is a chore
    sb=$(( 110 + $namesize ))
    sb=$(( $sb + (( 4 - ( $sb % 4 )) % 4 ) ))

    # + file payload + padding
    sb=$(( $sb + $filesize ))
    sb=$(( $sb + (( 4 - ( $sb % 4 )) % 4 ) ))
  
    current_base=$current_base+$sb
    
    return 0
}




cmd_line $1

fin=0;
until [ $fin = 1 ]; do
    get_one_file
    fin=$?
done

